.. _`Binary Extensions`:

============
バイナリ拡張
============

:Page Status: Incomplete
:Last Reviewed: 2013-12-08

CPython リファレンスインタプリタの一つの特徴は、Python コードを実行す
るだけでなく、他のソフトウェアから利用できる豊富な C API を提供してい
ることだ。この C API の最も一般的な使い方の一つは、インポート可能な C
拡張を作り、pure Python コードでは容易にはできないことを可能にすること
だ。

.. contents:: Contents
   :local:

バイナリ拡張の概要
==================

ユースケース
------------

バイナリ拡張の典型的なユースケースは、慣例的には 3 つのカテゴリに分か
れる:

* 高速化モジュール: これらのモジュールは完全に自己完結していて、単に
  CPython で動く同等な pure Python コードより高速に動作するために作ら
  れる。理想的には、高速化モジュールは同等な pure Python モジュールを
  常に備えており、あるシステムで高速版が利用できないときの fallback と
  して使えるようになっているべきだ。CPython 標準ライブラリでは高速化モ
  ジュールが広く使われている。

* ラッパーモジュール: これらのモジュールは既存の C インターフェースを
  Python コードから利用するために作られる。これらは基礎となる C イン
  ターフェースを直接公開するかもしれないし、あるいは API を使いやすく
  するために Python 言語機能を利用し、より "Pythonic" な API を公開す
  るかもしれない。CPython 標準ライブラリではラッパーモジュールが広く使
  われている。

* 低レベルシステムアクセス: これらのモジュールは CPython ランタイムの
  より低レベルな機能や、オペレーティングシステム、または基礎となるハー
  ドウェアにアクセスするために作られる。プラットフォーム固有のコードに
  より、拡張モジュールは pure Python コードでは不可能なことができるか
  もしれない。いくつかの CPython 標準ライブラリは C で書かれており、言
  語レベルでは公開されていないインタプリタの内部機能にアクセスしてい
  る。

  C 拡張の特筆すべき機能の一つは、インタプリタランタイムへコールバック
  する必要がない場合、時間のかかる操作(CPU bound か IO bound かによる
  が)の間、CPython の GIL (global interpreter lock) を解放できること
  だ。

全ての拡張モジュールが以上のカテゴリにきっちり当てはまるわけではない。
例えば、NumPy に含まれる拡張モジュールはこれら 3 つのユースケース全て
にわたっている - 速度上の理由で内部ループを C に移し、C, FORTRAN その
他の言語で書かれた外部ライブラリをラップし、また CPython および基礎と
なるオペレーティングシステムの低レベルインターフェースを使うことで、ベ
クトル化演算の並列実行をサポートし、作成されるオブジェクトのメモリレイ
アウトを厳密に制御している。


欠点
----

バイナリ拡張を使う主な欠点は、その後のソフトウェア配布がより難しくなる
ことだ。Python を使う利点の一つはその大部分がクロスプラットフォームで
あることだが、拡張モジュールを書くのに使われる言語(普通は C か C++ だ
が、実際は CPython C API にバインドできるなら何でもよい)は通常、プラッ
トフォームごとにカスタムバイナリを作る必要がある。

つまり、バイナリ拡張は:

* エンドユーザがソースからビルドできるか、または誰かが共通のプラット
  フォーム用のビルド済みバイナリを公開している必要がある。

* CPython リファレンスインタプリタの異なるビルドに対して互換性がないか
  もしれない。

* PyPy, IronPython, Jython などの代替インタプリタではしばしば正しく動
  かない。

* 手で書かれている場合、メンテナンスがより難しくなる。なぜならメンテナ
  は Python だけでなく、バイナリ拡張の作成に使われる言語や CPython C
  API の詳細にも精通していなければならないからだ。

* Pure Python の fallback 実装が提供されている場合、メンテナンスがより
  難しくなる。なぜなら変更点は 2 箇所で実装する必要があり、両方のバー
  ジョンが常に動作することを保証するためのテストスイートはさらに複雑化
  するからだ。

バイナリ拡張に頼ることのもう一つの欠点は、代替インポートメカニズム(例
えば zip ファイルからモジュールを直接インポートする機能)が拡張モジュー
ルではしばしば動作しないことだ(ほとんどのプラットフォームにおける動的
ロードメカニズムは、ディスクからライブラリをロードすることしかできない
ので)。


手書きの高速化モジュールに対する代案
------------------------------------

拡張モジュールが単にコードを速く実行するために使われているだけなら(プ
ロファイリングで速度向上がメンテナンスコストに見合うコードを見分けた後
で)、他の選択肢もいくつか考慮すべきだ:

* 既に最適化されたものがないか探す。CPython 標準ライブラリは多くの最適
  化されたデータ構造とアルゴリズムを含む(特に、組み込み関数と
  ``collections`` および ``itertools`` モジュールにおいて)。Python
  Package Index にはさらなる選択肢がある。場合によっては、標準ライブラ
  リやサードパーティモジュールを適切に選ぶことで、独自の高速化モジュー
  ルを作る必要がなくなる。

* 長時間動作するアプリケーションでは、JIT コンパイル機能を持つ `PyPy
  インタプリタ <http://pypy.org/>`__ を標準 CPython ランタイムの代わり
  に使うのが適切かもしれない。PyPy を採用する上で主な障害となるのは、
  他のバイナリ拡張モジュールへの依存だ - PyPy は確かに CPython C API
  をエミュレートするのだが、それに依存するモジュールは PyPy JIT で問題
  を起こすことがあり、またエミュレーションレイヤはしばしば CPython が
  現在許容している拡張モジュールの潜在的欠陥の影響を受ける(よくあるの
  は参照カウント周りのエラーだ - オブジェクトの参照カウント 2 が 1 に
  なったとしても問題はないだろうが、1 が 0 になるのは重大な問題だ)。

* `Cython <http://cython.org/>`__ は成熟した静的コンパイラで、ほとんど
  の Python コードを C 拡張モジュールへコンパイルできる。最初のコンパ
  イルで (CPython インタプリタレイヤを介さないことで)いくらか速度が向
  上する。また、Cython のオプションの静的型付け機能によりさらなる速度
  向上が見込める。Cython を使うと完成したアプリケーションの配布が複雑
  化する欠点はあるものの、Python プログラマにとって参入障壁が低い利点
  がある(C や C++ のような他の言語に比べれば)。

* `Numba <http://numba.pydata.org/>`__ はより新しいツールで、科学
  Python コミュニティのメンバーにより作られた。これは LLVM を活用し、
  実行時に Python アプリケーションをネイティブコードへ選択的にコンパイ
  ルできるようにするのが目的だ。コードが実行されるシステムで LLVM が利
  用可能でなければならないが、大幅な速度向上が見込める。ベクトル化に適
  した操作では特にそうだ。


手書きのラッパーモジュールに対する代案
--------------------------------------

C ABI (Application Binary Interface) は複数のアプリケーション間で機能
を共有するための標準だ。CPython C API (Application Programming
Interface) の強みの一つは、Python ユーザがこの機能を利用できることだ。
しかし、ラッパーモジュールを手で書くのはかなり退屈な作業なので、他のア
プローチをいくつか見当すべきだ。

以下で述べるアプローチは配布を簡単にするものではないが、ラッパーモ
ジュールを最新に保つメンテナンス負担を大幅に軽減 *できる* 。

* `Cython <http://cython.org/>`__ は高速化モジュールだけでなく、ラッ
  パーモジュールの作成にも役立つ。ただしインターフェースは依然として手
  でラップしなければならないので、大きな API をラップする場合はよい選
  択肢ではないかもしれない。

* `cffi <http://cffi.readthedocs.org/>`__ は PyPy 開発者の一部が作った
  プロジェクトで、Python と C の両方を知っているプログラマが C モ
  ジュールを Python アプリケーション向けに公開するのを容易にするのが目
  的だ。また、C を知らなくても、ヘッダファイルに基づいて C モジュール
  をラップするのを比較的容易にしてくれる。

  ``cffi`` の主な利点の一つは、PyPy JIT と互換性があることだ。これによ
  り、CFFI ラッパーモジュールは PyPy のトレース JIT 最適化の完全な恩恵
  を受けられる。

* `SWIG <http://www.swig.org/>`__ はラッパーインターフェース生成器で、
  Python を含む様々な言語が C *および C++* コードと連携できるようにす
  る。

* 標準ライブラリの ``ctypes`` モジュールは、ヘッダファイルがないときに
  C レベルのインターフェースにアクセスするのに便利だが、C ABI レベルで
  しか動作しないのが難点だ。このため、実際にライブラリがエクスポートす
  るインターフェースと Python コードで宣言されたそれとの間の一貫性の自
  動チェックは一切行われない。対照的に、上記の選択肢は全て C *API* レ
  ベルで動作でき、C ヘッダファイルを使うことで、ラップ対象のライブラリ
  がエクスポートするインターフェースと Python ラッパーモジュールが期待
  するそれとの間の一貫性を保証できる。 ``cffi`` は直接 C ABI レベルで
  も動作 *できる* が、そのような使い方をすると ``ctypes`` と同様のイン
  ターフェースの一貫性に関する問題を抱えることになる。


低レベルシステムアクセスに対する代案
------------------------------------

(理由を問わず)低レベルシステムアクセスを必要とするアプリケーションで
は、バイナリ拡張モジュールがしばしば最善の方法 *だ* 。CPython ランタイ
ム自身への低レベルアクセスについては特にそうだ。なぜなら、ある種の操作
(GILの解放など)はインタプリタがコードを実行中だと単に無効化されるから
だ。これはたとえ ``ctypes`` や ``cffi`` のようなモジュールを使って関連
C API インターフェースにアクセスしても同様だ。

拡張モジュールが(CPython ランタイムではなく)基礎となるオペレーティング
システムやハードウェアを操作している場合は、単に普通の C ライブラリ(ま
たは C++ や Rust のような C 互換 ABI をエクスポートできるシステムプロ
グラミング言語のライブラリ)を書き、それから上記のラッピング手法のどれ
かを使って Python モジュールとしてインポートできるインターフェースを作
る方がよい場合もあるかもしれない。


バイナリ拡張の実装
==================

::

   mention the stable ABI (3.2+, link to the CPython C API docs)
   mention the module lifecycle
   mention the challenges of shared static state and subinterpreters
   mention the implications of the GIL for extension modules
   mention the memory allocation APIs in 3.4+

   mention again that all this is one of the reasons why you probably
   *don't* want to handcode your extension modules :)


バイナリ拡張のビルド
====================

Windows 上でのビルド環境構築
----------------------------

バイナリ拡張をビルドする前に、適切なコンパイラが利用できることを確認す
る必要がある。Windows では、Visual C が公式 CPython インタプリタのビル
ドに使われており、互換性のあるバイナリ拡張のビルドにもこれを使うべき
だ。

Python 2.7 は Visual Studio 2008 を使っており、Python 3.3 と 3.4 は
Visual Studio 2010 を使っており、Python 3.5+ は Visual Studio 2015 を
使っている。残念ながら、旧バージョンの Visual Studio はもはや
Microsoft から容易に入手できなくなった。よって、Python 3.5 より前の
バージョンについては、別の方法でコンパイラを入手しなければならない(必
要なバージョンの Visual Studio を既に持っているのでなければ)。

バイナリ拡張のビルド環境構築手順は以下の通り:

    Python 2.7 の場合

        1. "Visual C++ Compiler Package for Python 2.7" をインストール
           する。これは `Microsoft のウェブサイト
           <https://www.microsoft.com/en-gb/download/details.aspx?id=44266>`__
           から入手できる。
        2. setup.py で(最新バージョンの) setuptools を使うようにする
           (いずれにしろ、pip がこれを行ってくれる)。
        3. 完了。

    Python 3.4 の場合

        1. "Windows SDK for Windows 7 and .NET Framework 4" (v7.1) を
           インストールする。これは `Microsoft のウェブサイト
           <https://www.microsoft.com/en-gb/download/details.aspx?id=8279>`__
           から入手できる。
        2. SDK のコマンドプロンプトを使うようにする(環境変数が設定さ
           れ、SDK が PATH に登録される)。
        3. 環境変数 DISTUTILS_USE_SDK=1 を設定する。
        4. 完了。

    Python 3.5 の場合

        1. `Visual Studio 2015 Community Edition
           <https://www.visualstudio.com/en-us/downloads/download-visual-studio-vs.aspx>`__
           (または、リリースされていればより新しいバージョン)をインス
           トールする。
        2. 完了。

Python 3.5 以降では、Visual Studio は後方互換性のある方法で動作するた
め、今後の任意のバージョンの Visual Studio で Python 3.5 以降の全バー
ジョンの Python 拡張をビルドできる。

::

   FIXME

   cover Windows binary compatibility requirements
   cover Mac OS X binary compatibility requirements
   cover the vagaries of Linux distros and other *nix systems



バイナリ拡張の公開
==================

::

   FIXME

   cover publishing as wheel files on PyPI or a custom index server
   cover creation of Windows and Mac OS X installers
   mention the fact that Linux distros have a requirement to build from
   source in their own build systems anyway, so pre-built binaries for
   *nix systems currently aren't common
